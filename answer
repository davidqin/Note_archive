1、
使用堆栈
申请一个临时节点指针，指向head
重复下述操作
将tmp压入栈中，然后tmp = tmp -> next，如果tmp -> next存在的话
tmp -> next = 弹出栈顶元素
tmp = tmp ->next

struct Node{
  int data;
  Node * next;
}

Node * tmp,top;
tmp = head;
stack<Node *> sk;

while(tmp -> next){
  sk.push(tmp);
  tmp = tmp -> next;
}

while(!sk.empty())
{
  top = sk.top();
  sk.pop();
  tmp -> next  = top;
  tmp = top;
}

不使用堆栈
Node * tmp,current,tail;
tail = head;
tmp = head -> next;
head -> next = NULL;
while(tmp)
{
  current = tmp;
  tmp = tmp -> next;
  current -> next = tail;
  tail = current;
}
head = current;

不是用堆栈临时节点，递归 

Node* ReverseNode(Node* oldNode,Node* newHead = NULL) 
{ 
  Node* next = oldNode -> next; 
  oldNode -> next = newHead; 
  newHead = oldNode; 
  return (next == NULL) ? newHead : ReverseNode( next, newHead); 
}


Node* reverseList(Node * oldNode, Node * newHead = NULL)
{ 
  
  Node * next  = oldNode -> next;
  oldNode -> next = newHead;
  newHead = oldNode;
  return (next == NULL) ? newHead : reverseList(oldNode, newHead);
}

2
随机抽取读过的书籍数目为10 和 30的用户各100名，
分别计算两个组内的用户对读过的书籍打分的平均值 
比较平均值
进行这个实验若干此，如果大部分情况内，都是。。。那么。。。
还可一适当的修改10 30 这两个数值，做几次实验


a[100];
int dp[100];
memset(dp,1,sizeof(dp));

users        id:integer
books        id:integer name:string
tags         id:integer name:string

follows      id:integer user_id:integer book_id:integer
follows_tags follow_id:integer tag_id:integer

select * from follows where user_id = 给出的用户id
select * from follows, follows_tags where follows_tags.follow_id = follows.id and user_id = 给出的用户id

select * from follows_tags where follow_id in (select id from follows where user_id = 给出的用户id)

select * from follows where user_id = 给的 and id in (select followe_id from follows_tags where tag_id = 给出的)

select * from tags where
(select tag_id,max(count(tag_id)) follows_tags where follow_id in（select id from follows where book_id = 给出的）group by tag_id)

users
books
tags
follows_tags id user_id book_id tag_id 

  1 3 5 9 2 3 4 5 6
  1 2 3 4 2 3 4 5 6
 
